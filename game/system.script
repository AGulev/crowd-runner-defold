local utils = require("game.utils")

local player_entity = nil
local enemies = {}

local TEMP_VECTOR = vmath.vector3(0) -- For memory optimization
local BOX_HALF_SIZE = 2500 -- 530 / 800 / 2500
local ENEMIES_COUNT = 16000 -- 2048 / 3300 / 16000
local FAR_DISTANCE = 200

local uid = 0
local function create_entity(game_object)
	local entity = {
		uid = uid,
		game_object = game_object,
		sprite_url = msg.url(nil, game_object, "sprite"),
		position = go.get_position(game_object),
		position_previous = go.get_position(game_object),
		move_vector = vmath.vector3(0),
		comp_vector = vmath.vector3(0),
		radius = 22,
		speed = 7,
		anim_current = nil,
		anim_run = "enemy_run",
		anim_idle = "enemy_idle",
		is_flip = false,
		frame_last_update = 0
	}
	uid = uid + 1
	utils.octotree_add(entity)
	return entity
end


local function calculate_comp_vector(entity)
	local position = entity.position

	utils.octotree_foreach(entity, function(other)
		TEMP_VECTOR.x = other.position.x - position.x
		TEMP_VECTOR.y = other.position.y - position.y
		local distance = vmath.length(TEMP_VECTOR)
		if distance ~= 0 then
			-- Calc comp vector
			TEMP_VECTOR.x = TEMP_VECTOR.x / distance
			TEMP_VECTOR.y = TEMP_VECTOR.y / distance
			if distance < entity.radius + other.radius then
				-- need to apply comp vector
				entity.comp_vector.x = entity.comp_vector.x - TEMP_VECTOR.x
				entity.comp_vector.y = entity.comp_vector.y - TEMP_VECTOR.y

				other.comp_vector.x = other.comp_vector.x + TEMP_VECTOR.x
				other.comp_vector.y = other.comp_vector.y + TEMP_VECTOR.y
			end
		end
	end)
end


local function calculate_move_vector(entity, other)
	if entity == other then
		return
	end

	local position = entity.position
	entity.move_vector.x, entity.move_vector.y = 0, 0

	TEMP_VECTOR.x = other.position.x - position.x
	TEMP_VECTOR.y = other.position.y - position.y
	local distance = vmath.length(TEMP_VECTOR)
	if distance ~= 0 and distance < FAR_DISTANCE then
		-- Normalize
		TEMP_VECTOR.x = TEMP_VECTOR.x / distance
		TEMP_VECTOR.y = TEMP_VECTOR.y / distance
		-- Need to apply move_vector
		entity.move_vector.x = entity.move_vector.x - TEMP_VECTOR.x
		entity.move_vector.y = entity.move_vector.y - TEMP_VECTOR.y
	end
end


local thresholds = {
	[300] = 2,
	[500] = 4,
	[600] = 8,
	[800] = math.huge,
}


local function is_skip_frame(entity, frame)
	TEMP_VECTOR.x = entity.position.x - player_entity.position.x
	TEMP_VECTOR.y = entity.position.y - player_entity.position.y
	local distance = vmath.length(TEMP_VECTOR)
	local threshold = 1
	for t_dist, t_value in pairs(thresholds) do
		if distance > t_dist and threshold < t_value then
			threshold = t_value
		end
	end

	return (frame + entity.uid) % threshold ~= 0
end


local function update_entity(entity, frame)
	if is_skip_frame(entity, frame) then
		return
	end

	-- Physics
	calculate_comp_vector(entity, utils.octotree_get_for(entity))
	calculate_move_vector(entity, player_entity)

	-- Get move delta vector
	TEMP_VECTOR.x = entity.move_vector.x + entity.comp_vector.x
	TEMP_VECTOR.y = entity.move_vector.y + entity.comp_vector.y
	TEMP_VECTOR.x = TEMP_VECTOR.x * entity.speed
	TEMP_VECTOR.y = TEMP_VECTOR.y * entity.speed
	entity.comp_vector.x = 0
	entity.comp_vector.y = 0

	-- Apply delta to position
	entity.position_previous.x = entity.position.x
	entity.position_previous.y = entity.position.y
	entity.position.x = entity.position.x + TEMP_VECTOR.x
	entity.position.y = entity.position.y + TEMP_VECTOR.y

	-- Restrict box size
	entity.position.x = math.min(math.max(entity.position.x, -BOX_HALF_SIZE), 960 + BOX_HALF_SIZE)
	entity.position.y = math.min(math.max(entity.position.y, -BOX_HALF_SIZE), 640 + BOX_HALF_SIZE)

	utils.octotree_update(entity)

	utils.check_flip(entity)
	utils.check_animation(entity)
	utils.update_z_position(entity)

	-- Update move
	go.set_position(entity.position, entity.game_object)
end



function init(self)
	self.frame = 0
	msg.post(".", "acquire_input_focus")
	player_entity = create_entity(go.get_id("/player"))
	player_entity.anim_run = "player_run"
	player_entity.anim_idle = "player_idle"
	player_entity.speed = 6

	for i = 1, ENEMIES_COUNT do
		TEMP_VECTOR.x = math.random(0 + 32 - BOX_HALF_SIZE, 960 - 32 + BOX_HALF_SIZE)
		TEMP_VECTOR.y = math.random(0 + 32 - BOX_HALF_SIZE, 640 - 32 + BOX_HALF_SIZE)
		local enemy_game_object = factory.create("#factory_enemy", TEMP_VECTOR, nil, nil, 4)
		table.insert(enemies, create_entity(enemy_game_object))
	end
end


function final(self)
	msg.post(".", "release_input_focus")
end


function update(self, dt)
	self.frame = self.frame + 1

	update_entity(player_entity, self.frame)
	for index = 1, #enemies do
		update_entity(enemies[index], self.frame)
	end
end


function on_input(self, action_id, action)
	if action_id == hash("key_a") then
		player_entity.move_vector.x = action.released and 0 or -1
	end

	if action_id == hash("key_d") then
		player_entity.move_vector.x = action.released and 0 or  1
	end

	if action_id == hash("key_w") then
		player_entity.move_vector.y = action.released and 0 or  1
	end

	if action_id == hash("key_s") then
		player_entity.move_vector.y = action.released and 0 or -1
	end

	if action_id == hash("key_p") and action.pressed then
		self._profiler_enabled = not self._profiler_enabled
		profiler.enable_ui(self._profiler_enabled)
	end
end
